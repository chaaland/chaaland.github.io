---
title: "CORDIC"
categories:
  - Algorithms
date:   2025-03-14 14:33:00 +0100
mathjax: true
tags:
  - Trigonometry
  - Numerical computing
toc: true
# classes: wide
excerpt: ""
header: 
  overlay_image: assets/cordic/images/splash_image.png
  overlay_filter: 0.2
---

## Motivation

## Sine and Cosine

Suppose we want to compute the sine and cosine of $$\pi/5$$.
With CORDIC, we start with a unit vector lying on the positive $$x$$-axis which has an angle of 0.

<figure class>
    <a href="/assets/cordic/images/cordic_00.png"><img src="/assets/cordic/images/cordic_00.png"></a>
    <figcaption>Figure 1: Initialisation of the CORDIC algorithm.</figcaption>
</figure>

We then rotate the vector counter-clockwise by $$\arctan(1) = \pi / 4$$ as shown in Figure 2.

<figure class>
    <a href="/assets/cordic/images/cordic_01.png"><img src="/assets/cordic/images/cordic_01.png"></a>
    <figcaption>Figure 2: First iteration of CORDIC.</figcaption>
</figure>

We see that this overshoots our target angle of $$\pi /5$$ so we rotate the vector clockwise by $$\arctan(1/2)$$ as shown in Figure 3.

<figure class>
    <a href="/assets/cordic/images/cordic_02.png"><img src="/assets/cordic/images/cordic_02.png"></a>
    <figcaption>Figure 3: Second iteration of CORDIC.</figcaption>
</figure>

This new vector still underestimates the target angle so we rotate clockwise again, but this time by $$\arctan(1/4)$$.

<figure class>
    <a href="/assets/cordic/images/cordic_03.png"><img src="/assets/cordic/images/cordic_03.png"></a>
    <figcaption>Figure 4: Third iteration of CORDIC.</figcaption>
</figure>

We repeat this process of rotating clockwise or counterclockwise depending on whether our vector is currently over or under the desired angle.
Each iteration, the angle we rotate by gets progressively smaller.
Specifically, the angle at iteration $$k$$ is given by $$\arctan(2^{-k})$$.
This is repeated either for a finite number of iterations or until some tolerance is reached.

<figure class>
    <a href="/assets/cordic/images/cordic_11.png"><img src="/assets/cordic/images/cordic_11.png"></a>
    <figcaption>Figure 5: 11 iterations of CORDIC.</figcaption>
</figure>

The sine and cosine of $$\pi / 5$$ are then given by the $$y$$ and $$x$$ components of the final vector.

But how is the rotation of the vector computed?
Why are we rotating by this particular angle sequence?
Wouldn't it be simpler to use a sequence like $${\pi \over 4 \cdot 2^{k}}$$, decreasing the angle by half each time?

Starting with the first of these questions, the rotation matrix for an angle $$\theta$$ measured counter clockwise from the positive x-axis is given by

$$
U_\theta =
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix} =
\cos \theta
\begin{bmatrix}
1 & -\tan \theta \\
\tan \theta & 1 \\
\end{bmatrix}
$$

Using our angle schedule of $$\theta_k = \arctan (2^{-k})$$, we see that each iteration of CORDIC algorithm is performing the rotation

$$U_{\theta_k} =
\cos(\arctan(2^{-k}))
\begin{bmatrix}
1 & -\sigma_k\cdot \tan(\arctan(2^{-k})) \\
\sigma_k \cdot \tan(\arctan(2^{-k})) & 1 \\
\end{bmatrix}
$$

where $$\sigma_k$$ is 1 if the rotation is clockwise and -1 if counter-clockwise.
The cosine term essentially asks "what is the cosine of the angle whose tangent is $$2^{-k}$$?".
If the tangent is $$2^{-k}$$, then the opposite leg of the right triangle can be treated as $$2^{-k}$$ while the adjacent leg is 1.
This makes the hypotenuse $$\sqrt{1+2^{-2k}}$$, making  $$\cos \theta_k = {1 \over \sqrt{1+2^{-2k}}}$$.

Our CORDIC rotation then simplifies to

$$U_{\theta_k} =
{1 \over \sqrt{1+2^{-2k}}}
\begin{bmatrix}
1 & -\sigma_k\cdot 2^{-k} \\
\sigma_k\cdot 2^{-k} & 1 \\
\end{bmatrix}
$$

It now becomes clear why we chose the angle schedule of $$\theta_k = \arctan(2^{-k})$$ rather than simply halving the angle at each iteration.

The rotation matrix requires computing the tangent.
Defining the angle based on the arctangent makes the computation trivial.
In applications using fixed point arithmetic (rather than floating point), this is as simple as a k-bit left shift.

In fact, plotting the two angle sequences, we see that the schedules are actually quite similar.

<figure class>
    <a href="/assets/cordic/images/angles.png"><img src="/assets/cordic/images/angles.png"></a>
    <figcaption>Figure 6: arctangent angle schedule vs halving angle schedule.</figcaption>
</figure>

The full CORDIC computation is just a cascade of matrix multiplications against the unit vector on the $$x$$-axis

$$v =
\left(\prod_{k=0}^{N-1} {1 \over \sqrt{1+2^{-2k}}}\right)
\begin{bmatrix}
1 & -\sigma_{N-1}\cdot 2^{-{N-1}} \\
\sigma_{N-1}\cdot 2^{-{N-1}} & 1 \\
\end{bmatrix}
\cdots
\begin{bmatrix}
1 & -\sigma_0\cdot 1 \\
\sigma_0\cdot 1 & 1 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
0 \\
\end{bmatrix}
$$

As shown in Figure 7, the gain

$$K_N = \prod_{k=0}^{N-1} \left(\sqrt{1 + 2^{-2k}}\right)^{-1/2}$$

converges rapidly to $$\approx 0.607$$ as $$N$$ approaches infinity.

<figure class>
    <a href="/assets/cordic/images/circular_gain.png"><img src="/assets/cordic/images/circular_gain.png"></a>
    <figcaption>Figure 7: CORDIC gain.</figcaption>
</figure>

## Hyperbolic Rotations

## Conclusion
